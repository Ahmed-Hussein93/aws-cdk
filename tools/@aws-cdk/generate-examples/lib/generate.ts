import * as spec from '@jsii/spec';
import { TypeSystem } from 'jsii-reflect';

export class ExampleContext {
  typeSystem: TypeSystem;
  breaker: Set<string> = new Set();
  assumptions: string[] = [];

  constructor(typeSystem: TypeSystem) {
    this.typeSystem = typeSystem;
  }
}

export function generateClassExample(typeSystem: TypeSystem, classType: spec.ClassType): string {
  const example: string[] = [];
  // TODO: Classes without initializer or protected initializer
  if (classType.abstract) {
    // eslint-disable-next-line no-console
    console.log(`${classType.fqn} is an abstract class`);
  } else if (isStaticClass(classType.properties)) {
    // eslint-disable-next-line no-console
    console.log(`${classType.fqn} is an enum-like class`);
  } else {
    // eslint-disable-next-line no-console
    console.log(`${classType.fqn} could have example`);
    example.push('// This example was autogenerated. You will have to change the values.\n');
    example.push(`new ${classType.name}`);
    const exampleContext = new ExampleContext(typeSystem);
    example.push(parenthesize(`${buildExample(exampleContext, classType, 1)}\n`));
  }
  return example.join('');
}

// TODO: not just properties but also methods
/**
 * Checks whether a class has only static methods, excluding the constructor.
 */
function isStaticClass(properties: spec.Property[] | undefined): boolean {
  // TODO: more robust checking for constructor method.
  let once = false;
  for (const prop of properties ?? []) {
    if (!prop.static) {
      if (once) {
        return false;
      }
      once = true;
    }
  }
  return true;
}

function buildExample(context: ExampleContext, type: spec.Type, level: number): string {
  // Check if we are infinitely recursing
  if (context.breaker.has(type.fqn)) {
    context.assumptions.push(type.fqn);
    return '';
  }

  const example: string[] = [];
  if (spec.isClassType(type) && !isStaticClass(type.properties)) {
    for (const params of type.initializer?.parameters ?? []) {
      if (params.name === 'scope' || params.name === 'id') {
        example.push(`${params.name === 'scope' ? 'this' : 'id'}, `);
      } else if (params.name === 'props') {
        context.breaker.add(type.fqn);
        example.push(`${addProp(context, params.type, params.name, level)}`);
        context.breaker.delete(type.fqn);
      } else {
        context.breaker.add(type.fqn);
        example.push(`${tab(level)}${params.name}: ${addProp(context, params.type, params.name, level)},\n`);
        context.breaker.delete(type.fqn);
      }
    }
  } else if (spec.isClassType(type) && isStaticClass(type.properties)) {
    example.push(`${tab(level)}${type.name}.${type.properties![0].name},\n`);
  } else if (spec.isEnumType(type)) {
    example.push(`${tab(level)}${type.name}.${type.members[0].name},\n`);
  } else if (spec.isInterfaceType(type)) {
    for (const props of type.properties ?? []) {
      context.breaker.add(type.fqn);
      example.push(`${tab(level)}${props.name}: ${addProp(context, props.type, props.name, level)},\n`);
      context.breaker.delete(type.fqn);
    }
    example.push(tab(level-1));
  }
  return example.join('');
}

function addProp(context: ExampleContext, typeReference: spec.TypeReference, name: string, level: number): string {
  // Process primitive types, base case
  if (spec.isPrimitiveTypeReference(typeReference)) {
    switch (typeReference.primitive) {
      case spec.PrimitiveType.String: {
        return `'${name}'`;
      }
      case spec.PrimitiveType.Number: {
        return '0';
      }
      case spec.PrimitiveType.Boolean: {
        return 'false';
      }
      case spec.PrimitiveType.Any: {
        return '\'any-value\'';
      }
      default: {
        return '---';
      }
    }
  }

  // Just pick the first type if it is a union type
  if (spec.isUnionTypeReference(typeReference)) {
    // console.log('union: ',name, JSON.stringify(typeReference));
    // TODO: which element should get picked?
    for (const newType of typeReference.union.types) {
      if (spec.isNamedTypeReference(newType) && newType.fqn.endsWith('.IResolvable')) {
        continue;
      }
      return addProp(context, newType, name, level);
    }
    const newType = typeReference.union.types[0];
    return addProp(context, newType, name, level);
  }

  // If its a collection create a collection of one element
  if (spec.isCollectionTypeReference(typeReference)) {
    //console.log('collectioN: ',name, typeReference);
    const collection = typeReference.collection;
    if (collection.kind === spec.CollectionKind.Array) {
      return inArray(`${addProp(context, collection.elementtype, name, level+1)}`);
    } else {
      return inObject(`${addProp(context, collection.elementtype, name, level+1)}`);
    }
  }

  // Process objects recursively
  if (spec.isNamedTypeReference(typeReference)) {
    //console.log('named: ',name, typeReference);
    const fqn = typeReference.fqn;
    // See if we have information on this type in the assembly
    const nextType = context.typeSystem.tryFindFqn(fqn)?.spec;
    //console.log('nextType: ', nextType?.fqn, typeReference.fqn);
    if (nextType) {
      return inObject(`\n${buildExample(context, nextType, level+1)}`);
    }
    return 'DNE';
  }

  return 'OH NO';
}

function tab(level: number): string {
  return '  '.repeat(level);
}

function parenthesize(fragment: string): string {
  return `(${fragment})`;
}

function inObject(fragment: string): string {
  return `{${fragment}}`;
}

function inArray(fragment: string): string {
  return `[${fragment}]`;
}