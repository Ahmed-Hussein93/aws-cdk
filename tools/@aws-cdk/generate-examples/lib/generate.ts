import * as spec from '@jsii/spec';
import { TypeSystem } from 'jsii-reflect';

export class ExampleContext {
  typeSystem: TypeSystem;
  breaker: Set<string> = new Set();
  assumptions: string[] = [];

  constructor(typeSystem: TypeSystem) {
    this.typeSystem = typeSystem;
  }
}

export function generateClassExample(typeSystem: TypeSystem, classType: spec.ClassType): string {
  const example: string[] = [];
  // TODO: Classes without initializer or protected initializer
  if (classType.abstract) {
    // eslint-disable-next-line no-console
    console.log(`${classType.fqn} is an abstract class`);
    return '';
  } else if (isStaticClass(classType)) {
    // eslint-disable-next-line no-console
    console.log(`${classType.fqn} is an enum-like class`);
    return '';
  } else {
    // eslint-disable-next-line no-console
    console.log(`${classType.fqn} could have example`);
    example.push(`new ${classType.name}`);
    const exampleContext = new ExampleContext(typeSystem);
    example.push(`${parenthesize(`${buildExample(exampleContext, classType, 0)}`)};`);

    addAssumptions(example, exampleContext.assumptions);
    example.unshift('// This example was autogenerated. You will have to change the values.\n');
    return example.join('');
  }
}

function addAssumptions(example: string[], assumptions: string[]) {
  const used: Record<string, number> = {};
  const declarations: string[] = [];
  for (const assumpt of assumptions) {
    let name = lowercaseFirstLetter(assumpt.split('.')[1]);
    if (used[name]) {
      used[name] += 1;
      name = name + used[name].toString();
    } else {
      used[name] = 1;
    }
    declarations.push(`declare const ${name}: ${module(assumpt)}.${typeName(assumpt)};\n`);
  }
  example.unshift(...declarations);
}

/**
 * Checks whether a class has only static methods or properties, excluding the constructor.
 */
function isStaticClass(classType: spec.ClassType): boolean {
  return allStaticMethods(classType.methods) || allStaticProps(classType.properties);
}

function allStaticProps(properties: spec.Property[] | undefined): boolean {
  if (!properties) {
    return false;
  }
  // TODO: more robust checking for constructor method.
  let once = false;
  for (const prop of properties) {
    if (!prop.static) {
      if (once) {
        return false;
      }
      once = true;
    }
  }
  return true;
}

function allStaticMethods(methods: spec.Method[] | undefined): boolean {
  if (!methods) {
    return false;
  }
  for (const meth of methods) {
    if (!meth.static) {
      return false;
    }
  }
  return true;
}

function buildExample(context: ExampleContext, type: spec.Type, level: number): string {
  // Check if we are infinitely recursing
  if (context.breaker.has(type.fqn)) {
    context.assumptions.push(type.fqn);
    return '';
  }

  const example: string[] = [];
  if (spec.isClassType(type)) {
    if (isStaticClass(type)) {
      if (allStaticMethods(type.methods)) {
        example.push(`${tab(level)}${module(type.fqn)}.${type.name}.${type.methods![0].name},\n`);
      } else {
        example.push(`${tab(level)}${module(type.fqn)}.${type.name}.${type.properties![0].name},\n`);
      }
    } else {
      for (const params of type.initializer?.parameters ?? []) {
        if (params.name === 'scope' || params.name === 'id') {
          example.push(`${params.name === 'scope' ? 'this' : 'id'}, `);
        } else if (params.name === 'props') {
          context.breaker.add(type.fqn);
          example.push(`${addProp(context, params.type, params.name, level)}`);
          context.breaker.delete(type.fqn);
        } else {
          context.breaker.add(type.fqn);
          example.push(`${tab(level)}${params.name}: ${addProp(context, params.type, params.name, level)},\n`);
          context.breaker.delete(type.fqn);
        }
      }
    }
  } else if (spec.isEnumType(type)) {
    example.push(`${tab(level)}${module(type.fqn)}.${type.name}.${type.members[0].name},\n`);
  } else if (spec.isInterfaceType(type)) {
    for (const props of type.properties ?? []) {
      context.breaker.add(type.fqn);
      example.push(`${tab(level)}${props.name}: ${addProp(context, props.type, props.name, level)},\n`);
      context.breaker.delete(type.fqn);
    }
    example.push(tab(level-1));
  }
  return example.join('');
}

function addProp(context: ExampleContext, typeReference: spec.TypeReference, name: string, level: number): string {
  // Process primitive types, base case
  if (spec.isPrimitiveTypeReference(typeReference)) {
    switch (typeReference.primitive) {
      case spec.PrimitiveType.String: {
        return `'${name}'`;
      }
      case spec.PrimitiveType.Number: {
        return '0';
      }
      case spec.PrimitiveType.Boolean: {
        return 'false';
      }
      case spec.PrimitiveType.Any: {
        return '\'any-value\'';
      }
      default: {
        return '---';
      }
    }
  }

  // Just pick the first type if it is a union type
  if (spec.isUnionTypeReference(typeReference)) {
    // console.log('union: ',name, JSON.stringify(typeReference));
    // TODO: which element should get picked?
    for (const newType of typeReference.union.types) {
      if (spec.isNamedTypeReference(newType) && newType.fqn.endsWith('.IResolvable')) {
        continue;
      }
      return addProp(context, newType, name, level);
    }
    const newType = typeReference.union.types[0];
    return addProp(context, newType, name, level);
  }

  // If its a collection create a collection of one element
  if (spec.isCollectionTypeReference(typeReference)) {
    //console.log('collectioN: ',name, typeReference);
    const collection = typeReference.collection;
    if (collection.kind === spec.CollectionKind.Array) {
      // FIXME levels
      return inArray(`${addProp(context, collection.elementtype, name, level)}`);
    } else {
      return inObject(`${addProp(context, collection.elementtype, name, level+1)}`);
    }
  }

  // Process objects recursively
  if (spec.isNamedTypeReference(typeReference)) {
    //console.log('named: ',name, typeReference);
    const fqn = typeReference.fqn;
    // See if we have information on this type in the assembly
    const nextType = context.typeSystem.tryFindFqn(fqn)?.spec;
    //console.log('nextType: ', nextType?.fqn, typeReference.fqn);
    if (nextType) {
      return inObject(`${isEmpty(`\n${buildExample(context, nextType, level+1)}`)}`);
    }
    // cannot find fqn
    context.assumptions.push(fqn);
    return lowercaseFirstLetter(fqn.split('.')[1]);
  }

  return 'OH NO';
}


function isEmpty(fragment: string): string {
  let newFragment: string;
  newFragment = fragment.trim();
  // eslint-disable-next-line no-console
  if (newFragment.length === 0) {
    return '';
  } else {
    return fragment;
  }
}

function lowercaseFirstLetter(str: string): string {
  return str.charAt(0).toLowerCase() + str.slice(1);
}

function tab(level: number): string {
  return '  '.repeat(level);
}

function parenthesize(fragment: string): string {
  return `(${fragment})`;
}

function inObject(fragment: string): string {
  return `{${fragment}}`;
}

function inArray(fragment: string): string {
  return `[${fragment}]`;
}

function module(fqn: string): string {
  const moduleName = fqn.split('/')[1].split('.')[0];
  const names = moduleName.split('-');
  return names[0] === 'aws' ? names[1] : names[0];
}

function typeName(fqn: string): string {
  const type = fqn.split('.');
  return type[1];
}